	
	<<jsp>>
		
		jsp는 응답 문서(hmtl 문서) 만들기 위한 언어
		따라서 html 코드가 중심이 되고 그 중에 필요한 경우에 한해서 자바 코드가 삽입될 수 있다.
		결국 jsp는 자바적 요소를 포함할 수 있는 스크립트 언어 
		(자바 실행이 가능하다, 웹브라우저에서 바로 실행되는 게 아니고 톰캣이 jsp 파일을 클래스 파일로 변환 후 실행하는 것이기 때문
		 톰캣 통하지 않고 바로 보는 경우는 텍스트 파일로만 보여준다.)
		 
		html : 서버측에서 실행 불가, 클라이언트(의 웹브라우저)에서 실행 가능한 언어
		 		미리 준비된 소스코드가 담긴 문서를 보내주는 것일 뿐 변화를 줄 순 없다.
		
		JSP : 서버 측에서만 실행 가능, 응답 문서 만드는 언어이기 때문.. 
				요청이 올 때마다 서버 측에서 실행해서 요청에 맞는 새로운 HTML 문서 제작 가능
				즉 매번 내용 변화가 가능하다.
				
		
		[구조]
			자바 소스 코드를 어떤 방식으로 HTML 문서에 포함시킬 것인가가 중요		
	
	
		[주석 처리]
			<%-- --%>		
========================

	<지시자>
		: JSP 문서의 특성이나 처리 방식을 지시하는 명령
		
		
		[형식]
			<%@ 명령어 속성="속성값"	속성="속성값"	%>
		
		
		[명령어 종류]
			1. page : 문서 자체의 특성이나 처리방식 지시, 필수
				
				[형식]
					<%@ page 속성="속성값"  속성="속성값"... %>
				
					속성 : 지정하고 싶은 특성이나 처리 방식에 대한 예약된 단어
					속성값 : 속성에 해당하는 특성이나 처리 방식에 대한 내용
					
					[속성 종류]
						*	language : 스크립트할 언어의 종류를 지정하는 속성(어떤 언어로 이 문서가 해석되어야 하는가)
										생략 시 자동으로 자바를 스크립트 해줌
								[예]
									<%@ page language="java" %>
						
						*	extends	: jsp는 실행 시 자바 클래스로 변환돼서 실행, 
										즉 중간 단계의 언어로 바뀐 상태에서 실행하므로 ASP, PHP보다 실행 속도가 빠르다.
										이 때 중간에서 만들어지는 클래스가 어떤 클래스를 상속 받아서 만들어져야 하는지를 지정하는 속성
										JSP 파일 자체가 자바 클래스로 변환되는데 이 클래스가 
										
										++) 클래스는 단일 상속, 인터페이스는 다중 구현
										
										이미 JSP 문서가 클래스로 변환될 때 HttpJspBase 라는 클래스를 상속받도록 약속을 해놓았다.
										자바는 다중 상속이 불가하므로 필요없는 속성..
										생략하면 자동적으로 HttpJspBase라는 클래스를 상속받아준다. (자바는 object)
								
								[예]
									<%@ page extends="javax.servlet.jsp.HttpJspBase" %> 
							
						*	import : 스크립트 안에 자바 코드 넣을 수 있음.
										이때 사용하는 자바 코드가 특정 패키지 소속이면 자바와 동일하게 반드시 import 해줘야 한다.
								
								[예]
									<%@ import="java.util.*, java.io.*, ..." %>
										
							session : 세션의 사용 여부를 판단하도록 하는 속성
										생략 시 세션 사용(기본값이 true)
								[예]
									<%@ page session="true" %>
									
									[참고]
										세션 : 사용자의 정보를 서버 측에서 관리할 때 메모리상에서 관리 하도록 하고 있다.
												메모리 상에 객체를 만들어 놓고 수정하고 관리, 이것이 세션
												서버에서 메모리에서 관리하는 사용자 정보를 세션이라고 한다.
										쿠키 : 클라이언트 측에서 서버의 정보, 자신의 활동 내역 등을 사용자 측의 컴퓨터의 파일로 저장해서 관리한다.
												이때 저장된 파일을 쿠키라고 부른다. 
												
							buffer : 내부적으로 버퍼 사용할지 여부와 버퍼 크기 지정하는 속성
										생략 시 8kbyte 버퍼로 사용
								
								[예]
									<%@ page buffer="none" @>
									==> 버퍼 사용 안함
									
									<%@ page buffer="16K" @>
									==> 버퍼 크기 16Kbyte로 지정해서 사용
								
								[참고]
									버퍼란?
										클라이언트에서 서버가 응답을 할 때 처리 속도를 빠르게 하기 위해서 
										중간에 버퍼를 사용해서 데이터를 모았다가 한 번에 출력
										다 차면 안에 있는 거 자동으로 꺼내고 다 안 차면 강제로 꺼내준다.
										
							autoFlush : 자동 Flush 기능을 사용할지 여부 판단하는 속성
										생략 시 true가 지정되어서 자동 flush 기능이 적용된다.
								
								[예]
									<%@ page autoFlush="true" %>
								
								[참고]
									false로 지정 시 강제로 flush 시켜줘야 한다...
										
							isThreadSafe : 스레드처리 시 동기화 처리 여부 결정하는 속성
											생략 시 자동 동기화 처리
									[예]
										<% page isThredSafe="true" %>
									
									[참고]
										jsp의 모든 문서는 자동 스레드 처리가 된다.
										즉, 여러 클라이언트가 동시에 접속해도 스레드 처리해서 응답하도록 돼있음
						
						*	info : 주석문에 해당하는 것으로 실행에는 지장 없음
									단 문서에 대한 정보를 달고 싶을 때 사용하는 속성
								[예]
									<%@ page info="pink프로젝트 jsp 파일" %>
									
						*	errorPage : jsp 문서 실행하는 도중 문제(exception) 발생 시 그 문서로 응답 불가
										이 때 대신 응답할 다른 문서 지정하는 속성
										
								[예]
									<%@ page errorPage="pinkError.jsp" %>
									 
						*	isErrorPage : 지금 만들고 잇는 문서가 에러 페이지용 문서인지 지정하는 속성
								
								[예]
									<%@ page isErrorPage="true" %>
						
						***	contentType : 실행 결과의 응답 방식 지정하는 속성
								
								[참고]
									실행 결과 탄생하는 문서 종류 지정 가능
									이때 응답 문서 종류는 MIME TYPE으로 지정해야..
									생략 시 일반 txt 파일로 응답, 따라서 반드시 지정
																	
								[예]
									<%@ page contentType="text/html" %>	
								
								[참고]
									이 속성에는 인코딩 방식도 같이 지정 가능
								
									[예]
										<%@ page contentType="mimeType; charset=UTF-8" %>
										
						pageEncoding : 문서의 인코딩 방식 지정하는 속성
									
									[예]
										<%@ page pageEncoding="UTF-8" %>
									
									[참고]
										contentType에서 문서의 인코딩 방식을 같이 지정할 수 있으므로 생략 가능
											
				 
			2. include : 문서 안에 다른 문서 포함하도록 지시, 하나의 파일로 만드는 기능
			
				[형식]
					<%@ include file="합칠파일이름" %>
				
				[참고]
					웹 문서를 만들다보면 여러 페이지에 같은 내용이 중복되어 추가되는 경우가 있음
					jsp 문서가 만든 결과를 응답하기 때문에 응답 문서는 하나로 만들어져야 한다.
					매 문서마다 동일한 내용이라도 다시 작성해야 하는 불편을 덜기 위해 사용
					
					자주 사용하는 내용은 따로 만들어 놓고 응답 문서에 만들어진 파일 합쳐서 하나의 문서로 만든다.
					
					먼저 코드를 합치고(하나의 문서로 만들고) 컴파일한다.
					만약 먼저 합쳤을 때 문제 발생 시(충돌나면) 에러 발생..
				    따로 컴파일하고 합치는 게 낫다!!
					
			3. taglib : 사용자가 제작한 태그 사용할 수 있도록 선언, 자바 명령어 태그로 만든 것들

=======================

	<jsp 코드 작성(스크립트) 방식>
		jsp는 html 언어가 기본이 되며 필요 시 자바 언어를 필요 위치에 삽입한다.
		
	<jsp 문서 실행 순서>	
		요청 => jsp 문서 자바 class로 변환 => 컴파일(.class) => 톰캣이 실행
		=> 실행 결과 만들어진 html 소스 코드 클라이언트에게 전송 => 실행
		
		[참고]
			이처럼 다른 언어에 포함하여 처리하는 방식을 스크립트 방식이라고 한다.
			jsp 문서에 자바 언어를 삽입하는 방식은 3가지 잇음
			
			1. 스크립트 릿 방식 
				: 일반적인 자바 언어를 포함하는 방식.
					이곳에 기록한 모든 내용은 service 함수 안에 작성된다.
					따라서 이곳은 결국 지역적인 역할을 하게 된다.
				
				[참고]
					jsp 문서는 여러 문서가 같이 실행되는 것이 아니고
					클라이언트가 요청한 문서 하나만 실행되므로
					클래스가 연결되어서 실행되는 경우는 거의 없다.
					따라서 메인함수만 있으면 충분히 그 역할을 수행할 수 있다.
				
				[참고]
					jsp 문서는 실행하면 먼저 자바 클래스로 변환된다.
					이것을 위 순서대로 실행..
					이런 클래스를 서블릿 클래스라고 한다..
					요청에 응답해주는 클래스, 서버 쪽에서 실행되는 클래스
					이것 역시 자바의 메인함수처럼 시작 함수가 존재하는데 그 함수 이름이 service 함수..
					
				[형식]
					<% 
						자바 코딩
					%>
					
				[참고]
					스크립트 릿 속에 있는 내용과 html적인 내용은 같이 service 함수에 코딩이 된다.
					따라서 두 가지는 혼용해서 사용 가능
					다만 자바적인 요소와 html 요소만 구분해주면 됨	 					
			
			
			2. 선언자 방식
				: jsp는 서비스 함수 안에서 거의 모든 것이 실행된다. 
					그러나 전역변수나 함수가 필요할 수도 있다. 이 때 사용하는 방식.
					전역변수와 함수를 만드는 기능을 가진 스크립트
					이 안에서는 일반 명령(println...)은 사용 불가
					
				
				[형식]
					<%!
						변수선언
						함수제작
					%>
					
			
			3. 표현자 방식
				: 자바에서의 System.out.prinln() 처럼 변수, 함수를 화면에 출력하기 위한 스크립트
			
				[형식]
					<%= 출력내용 %>
					
				[주의]
					출력내용은 오직 한 개만 가능
					println도 마찬가지..
					문자열 결합 이용해서 하나의 문자열로 만들어서 출력해야 함	
				
			
			주석문
				
				1. html, htm	
					<!-- -->
					
				2. 자바스크립트
					//
					/* */
				3. jsp
					1) html 부분
						<%-- --%>
					2) 스크립트 릿방식의 코드
						//
						/* */
						
=================================

	<<내장객체>>
	: 자주 사용하는 클래스 중 몇가지는 jsp 안에서 미리 new 시켜서 사용할 수 있도록 준비
		new 필요없이 사용하는 클래스가 내장객체
	
	1. out 객체
		PrintWriter(응답문서 만드는 도구) 클래스 미리 new 시켜놓은 내장 객체
		PrintWriter out = new PrintWrtier(); 미리 해둠
		클라이언트에게 응답하는 문서를 작성하도록 하는 기능... <%= %>과 동일
		
		[주요함수]
			write()
			flush()
		
		[참고]
			PrintWriter는 JSPWriter 클래스로 변환되어 new된 경우
		
		내장객체는 클래스를 사용하는 것
		클래스 내 원하는 함수가 무엇인지 파악해야 함	
				
	2. request 객체
		클라이언트의 요청 정보 관리하는 역할 하는 내장 객체
		즉, 요청한 클라이언트의 IP주소, 요청내용, 부가정보 원할 경우 사용
		
		HttpServletRequest를 이용해서 만들어진 내장 객체
		
		[주요함수]
			
			getParameter() : 서버 측에서 클라이언트가 준 부가정보를 알아내는 함수
				
				[형식]
					String ??? = request.getParameter("키값(input 태그의 name 값)");				
				
				[주의]
					부가 정보는 오직 String으로만 받을 수 있다.
					부가 정보를 셋팅하는 함수는 없다.
					
			getParameterValues() : 
				
				[형식]
					String[] ??? : request.getParameterValues("키값");
					
					=> input checkbox 넘길 때 사용
				
				[참고]
					클라이언트가 서버에게 요청하는 방법
					
					1. GET 방식
						1) URL에 입력해서 요청
						2) a 태그 이용해서 요청
						3) location 객체의 href 속성 정의하면서 요청
							
							location.href= '요청주소?키값=데이터&키값=데이터...';
							
						4) form 태그의 method 속성은 GET으로 하고 action 속성에 요청 주소 입력
						
						[참고]
							GET 방식으로 요청 시 부가 정보 같이 줄 수 있음
							
							[형식]	
								게시판 목록 보기 할 때 몇 페이지를 보여달라는 요청?
								<a href="요청할문서?키값=데이터&키값=데이터...">내용</a>
								
							[주의]
								? = & 앞뒤에는 공백 불가
								
							[참고]
								GET 방식은 요청 내용이 주소표시줄에 나타나기 때문에 보안에 취약
							
							[주의]
								부가정보에 한글 삽입 시 서버 측에서 받을 수 없음
								한글이 깨져서 나오는 경우
									
									[해결방법]
										
										1. 해당 문서에서만 해결
											
											<%
												request.setCharacterEncoding("UTF-8");
											%>
										
										2. 모든 문서에 해결
											
											server.xml 파일의 Connector 태그 마지막 부분에 URIEncoding="UTF-8" 추가 
					
					2. POST 방식
						1) form 제작해서 요청
							: 로그인 폼과 같이 사용자가 필요한 것을 입력 or 선택해서 서버에게 전달하는 방식
							
							[특징]
								반드시 <form> 안에 입력 태그를 만들어야 하고 만약 어떤 폼이 <form> 안에 없다면
								그 내용은 서버에 전달 불가
							
							[참고]
								이 때 반드시 이 폼의 내용을 전달할 도구를 준비
								이를 제출(submit)도구라고 한다.
								
								[제출도구 만드는 법]
									1. html 형식으로 만드는 법
										<input type="submit" value="제출">
										버튼 모양으로 나오지만 이 버튼을 클릭하면 
										form 태그 내의 입력 폼에 입력한 내용의 value 속성값이 서버에 제출
									
									
									2. 자바스크립트 형식으로 만드는 방법
										<script type="text/javascript">
											var frm = 폼태그를 선택;
											frm.submit();
										</script>
								
								[form 태그 작성 형식] : 모양 없고 제출용으로 만든 태그
									<form method="POST" action="요청문서" name="???" id="???">
										필요한 입력 폼 제작
									</form>
								
								[form 태그의 중요 속성]
									method : 데이터 전달 방식 (GET or POST)
									action : 서버가 받아서 처리할 문서
								
								
								[참고]
									post 방식은 스트림을 이용해서 서버에 전달하므로
									주소표시줄에 그 내용이 나오지 않는다.
									따라서 get 방식보다는 보안 굳	
								
								[참고]
									post 방식으로 주는 데이터의 한글 깨짐 방지 방법은
									서버가 필터링 이용해서 인코딩 해줘야 함
									
									web.xml 파일의 
										
										1. 필터를 만든다.
											<filter-name>
											필터 처리에 적당한 이름 부여					
											<filter-class>
											필터 처리에 사용할 클래스 지정
											<init-param>
											인코딩 방식 지정..
											
											 <filter>
										        <filter-name>setCharacterEncodingFilter</filter-name>
										        <filter-class>org.apache.catalina.filters.SetCharacterEncodingFilter</filter-class>
										        <init-param>
										            <param-name>encoding</param-name>
										            <param-value>UTF-8</param-value>
										        </init-param>
										      </filter>
											이 부분 찾아서 주석 해제
										
										2. 필터 적용시켜야 함
											  <filter-mapping>
										        <filter-name>setCharacterEncodingFilter</filter-name>
										        => 적용시킬 필터 이름 기입
										        <url-pattern>/*</url-pattern>
										        => 어떤 요청이 있는 경우 이 필터링을 사용할지 지정
										        	기본 셋팅이 /* 이므로 모든 요청에 대해서 필터링 한다는 뜻..
										      </filter-mapping>
										    
										    위 부분을 주석 해제
										
										[참고]
											<input type="text"..>
											<input type="password"..>
											<textarea>...</textarea>
											
											위 세 가지는 사용자가 입력한 내용이 서버에 전달
											
											위 세 가지 이외의 입력 태그는 화면에 보이는 내용이 전달되는 게 아니고
											value 속성으로 지정한 내용이 서버에 전달된다.
											따라서 입력상자 계열 이외의 폼을 제작할 시 반드시 value 속성 정의해야함
										
										[참고]
											만약 같은 <form> 안에 같은 name 속성이 여러 태그에 존재하는 경우
											모든 데이터가 배열 형식으로 전달된다.        
											
											이 경우
												request.getParameterValues("키값");
											으로 꺼낸다...
											
										[참고]
											제작한 폼이 라디오나 선택 박스인 경우 선택한 태그의 value 속성값만 서버에 전달됨
											
											특히 체크박스의 경우 선택, 취소로 서버에 전달되는 것으로 착각할 수 있으나
											선택된 태그의 value 속성값이 전달되는 것..             
																																
					location 객체 안의 href 속성
					search 속성 : 파라미터만 기억  
	
	3. response 객체 : 서버가 클라이언트에게 응답하는 정보 관리하는 내장객체
		
		HttpServletResponse 라는 클래스를 이용해서 만들어진 내장객체
		
		[주요함수]
			sendRedirect() : 서버측에서 강제로 클라이언트의 명령 변경하는 명령
								클라이언트가 a라는 문서를 요청했는데 서버측에서 강제로 b라는 문서로 응답하는 방법
			
								게시판 글쓰기 요청 시 글쓰기 작업 끝난 후 글쓰기 작업에 대한 응답을 하는 게 아니라
								강제로 목록을 보여주는 것이 일반적
								
								이처럼 서버는 가끔 필요하면 클라이언트의 요청(글쓰기)을 서버가 다른 요청(목록보기)로 바꿔야할 수 있따.	
				[참고]
					서버가 요청 바꾸는 방법
						
						1. redirect : 본래 클라이언트 요청 정보는 모두 잊고 완벽하게 새로운 요청으로 처리하는 방식
										request 객체가 새롭게 만들어진다.
										따라서 원래 클라이언트가 준 정보는 사라지며 새로고침 시 마지막 요청(서버가 바꾼 요청)부터 시작
										
						2. forward : 원래 클라이언트의 요청 정보 유지한 상태에서 화면에 보이는 문서만 바꿔치기\
										
										따라서 원래 클라이언트가 준 정보는 유지.(request 객체 유지)
										새로고침 시 처음부터 다시 시작. 즉, 클라이언트의 실제 요청부터 다시 시작 
	
	
		객체 : 서버 메모리에 올려진 것들..
	
	
 **	4. session 객체 : session 관리하는 내장객체
 
 		HttpSession이라는 클래스 이용해서 만들어진 내장 객체
		서버 접속하는 순간 무조건 new 되는 것
		
	5. application 객체 : 서버 전체 관리하는 내장객체
		
		ServletContext라는 클래스를 이용해서 만들어진 내장 객체
	
	6. page 객체 : 그 문서 자체를 관리하는 내장 객체
		
		PageContext라는 클래스 이용해서 만들어진 내장 객체 				
	
					